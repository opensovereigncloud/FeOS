// SPDX-FileCopyrightText: 2023 SAP SE or an SAP affiliate company and IronCore contributors
// SPDX-License-Identifier: Apache-2.0
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.12.4
// source: v1/vm.proto

package v1

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	VMService_CreateVm_FullMethodName        = "/feos.vm.vmm.api.v1.VMService/CreateVm"
	VMService_StartVm_FullMethodName         = "/feos.vm.vmm.api.v1.VMService/StartVm"
	VMService_GetVm_FullMethodName           = "/feos.vm.vmm.api.v1.VMService/GetVm"
	VMService_StreamVmEvents_FullMethodName  = "/feos.vm.vmm.api.v1.VMService/StreamVmEvents"
	VMService_DeleteVm_FullMethodName        = "/feos.vm.vmm.api.v1.VMService/DeleteVm"
	VMService_StreamVmConsole_FullMethodName = "/feos.vm.vmm.api.v1.VMService/StreamVmConsole"
	VMService_ListVms_FullMethodName         = "/feos.vm.vmm.api.v1.VMService/ListVms"
	VMService_PingVm_FullMethodName          = "/feos.vm.vmm.api.v1.VMService/PingVm"
	VMService_ShutdownVm_FullMethodName      = "/feos.vm.vmm.api.v1.VMService/ShutdownVm"
	VMService_PauseVm_FullMethodName         = "/feos.vm.vmm.api.v1.VMService/PauseVm"
	VMService_ResumeVm_FullMethodName        = "/feos.vm.vmm.api.v1.VMService/ResumeVm"
	VMService_AttachDisk_FullMethodName      = "/feos.vm.vmm.api.v1.VMService/AttachDisk"
	VMService_DetachDisk_FullMethodName      = "/feos.vm.vmm.api.v1.VMService/DetachDisk"
	VMService_AttachNic_FullMethodName       = "/feos.vm.vmm.api.v1.VMService/AttachNic"
	VMService_DetachNic_FullMethodName       = "/feos.vm.vmm.api.v1.VMService/DetachNic"
)

// VMServiceClient is the client API for VMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VMServiceClient interface {
	// Creates a new Virtual Machine but does not boot it.
	// This starts a cloud-hypervisor process, sets up its initial resources,
	// and makes it ready for booting. The returned 'vm_id' must be used for
	// all subsequent operations on this VM.
	CreateVm(ctx context.Context, in *CreateVmRequest, opts ...grpc.CallOption) (*CreateVmResponse, error)
	// Starts a previously created Virtual Machine.
	StartVm(ctx context.Context, in *StartVmRequest, opts ...grpc.CallOption) (*StartVmResponse, error)
	// Retrieves detailed information about a specific Virtual Machine.
	GetVm(ctx context.Context, in *GetVmRequest, opts ...grpc.CallOption) (*VmInfo, error)
	// Retrieves the events stream for a specific Virtual Machine.
	StreamVmEvents(ctx context.Context, in *StreamVmEventsRequest, opts ...grpc.CallOption) (VMService_StreamVmEventsClient, error)
	// Deletes an existing Virtual Machine and frees up its resources.
	DeleteVm(ctx context.Context, in *DeleteVmRequest, opts ...grpc.CallOption) (*DeleteVmResponse, error)
	// Provides an interactive console to a running VM.
	// This is a bidirectional stream. The client first sends an 'attach' message
	// with the VM ID, then streams user input. The server streams back the
	// VM's console output.
	StreamVmConsole(ctx context.Context, opts ...grpc.CallOption) (VMService_StreamVmConsoleClient, error)
	// Lists all Virtual Machines currently managed by this service.
	ListVms(ctx context.Context, in *ListVmsRequest, opts ...grpc.CallOption) (*ListVmsResponse, error)
	// Pings the VMM process for a specific VM to check for liveness.
	PingVm(ctx context.Context, in *PingVmRequest, opts ...grpc.CallOption) (*PingVmResponse, error)
	// Shuts down a running Virtual Machine by sending an ACPI shutdown signal.
	ShutdownVm(ctx context.Context, in *ShutdownVmRequest, opts ...grpc.CallOption) (*ShutdownVmResponse, error)
	// Pauses a running Virtual Machine.
	PauseVm(ctx context.Context, in *PauseVmRequest, opts ...grpc.CallOption) (*PauseVmResponse, error)
	// Resumes a paused Virtual Machine.
	ResumeVm(ctx context.Context, in *ResumeVmRequest, opts ...grpc.CallOption) (*ResumeVmResponse, error)
	// Hot-plugs a new disk to a running VM.
	AttachDisk(ctx context.Context, in *AttachDiskRequest, opts ...grpc.CallOption) (*AttachDiskResponse, error)
	// Hot-unplugs a disk from a running VM.
	DetachDisk(ctx context.Context, in *DetachDiskRequest, opts ...grpc.CallOption) (*DetachDiskResponse, error)
	// Hot-plugs a new network interface to a running VM.
	AttachNic(ctx context.Context, in *AttachNicRequest, opts ...grpc.CallOption) (*AttachNicResponse, error)
	// Hot-unplugs a network interface from a running VM.
	DetachNic(ctx context.Context, in *DetachNicRequest, opts ...grpc.CallOption) (*DetachNicResponse, error)
}

type vMServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVMServiceClient(cc grpc.ClientConnInterface) VMServiceClient {
	return &vMServiceClient{cc}
}

func (c *vMServiceClient) CreateVm(ctx context.Context, in *CreateVmRequest, opts ...grpc.CallOption) (*CreateVmResponse, error) {
	out := new(CreateVmResponse)
	err := c.cc.Invoke(ctx, VMService_CreateVm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StartVm(ctx context.Context, in *StartVmRequest, opts ...grpc.CallOption) (*StartVmResponse, error) {
	out := new(StartVmResponse)
	err := c.cc.Invoke(ctx, VMService_StartVm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) GetVm(ctx context.Context, in *GetVmRequest, opts ...grpc.CallOption) (*VmInfo, error) {
	out := new(VmInfo)
	err := c.cc.Invoke(ctx, VMService_GetVm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StreamVmEvents(ctx context.Context, in *StreamVmEventsRequest, opts ...grpc.CallOption) (VMService_StreamVmEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &VMService_ServiceDesc.Streams[0], VMService_StreamVmEvents_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &vMServiceStreamVmEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VMService_StreamVmEventsClient interface {
	Recv() (*VmEvent, error)
	grpc.ClientStream
}

type vMServiceStreamVmEventsClient struct {
	grpc.ClientStream
}

func (x *vMServiceStreamVmEventsClient) Recv() (*VmEvent, error) {
	m := new(VmEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vMServiceClient) DeleteVm(ctx context.Context, in *DeleteVmRequest, opts ...grpc.CallOption) (*DeleteVmResponse, error) {
	out := new(DeleteVmResponse)
	err := c.cc.Invoke(ctx, VMService_DeleteVm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) StreamVmConsole(ctx context.Context, opts ...grpc.CallOption) (VMService_StreamVmConsoleClient, error) {
	stream, err := c.cc.NewStream(ctx, &VMService_ServiceDesc.Streams[1], VMService_StreamVmConsole_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &vMServiceStreamVmConsoleClient{stream}
	return x, nil
}

type VMService_StreamVmConsoleClient interface {
	Send(*StreamVmConsoleRequest) error
	Recv() (*StreamVmConsoleResponse, error)
	grpc.ClientStream
}

type vMServiceStreamVmConsoleClient struct {
	grpc.ClientStream
}

func (x *vMServiceStreamVmConsoleClient) Send(m *StreamVmConsoleRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *vMServiceStreamVmConsoleClient) Recv() (*StreamVmConsoleResponse, error) {
	m := new(StreamVmConsoleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vMServiceClient) ListVms(ctx context.Context, in *ListVmsRequest, opts ...grpc.CallOption) (*ListVmsResponse, error) {
	out := new(ListVmsResponse)
	err := c.cc.Invoke(ctx, VMService_ListVms_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) PingVm(ctx context.Context, in *PingVmRequest, opts ...grpc.CallOption) (*PingVmResponse, error) {
	out := new(PingVmResponse)
	err := c.cc.Invoke(ctx, VMService_PingVm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ShutdownVm(ctx context.Context, in *ShutdownVmRequest, opts ...grpc.CallOption) (*ShutdownVmResponse, error) {
	out := new(ShutdownVmResponse)
	err := c.cc.Invoke(ctx, VMService_ShutdownVm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) PauseVm(ctx context.Context, in *PauseVmRequest, opts ...grpc.CallOption) (*PauseVmResponse, error) {
	out := new(PauseVmResponse)
	err := c.cc.Invoke(ctx, VMService_PauseVm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) ResumeVm(ctx context.Context, in *ResumeVmRequest, opts ...grpc.CallOption) (*ResumeVmResponse, error) {
	out := new(ResumeVmResponse)
	err := c.cc.Invoke(ctx, VMService_ResumeVm_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) AttachDisk(ctx context.Context, in *AttachDiskRequest, opts ...grpc.CallOption) (*AttachDiskResponse, error) {
	out := new(AttachDiskResponse)
	err := c.cc.Invoke(ctx, VMService_AttachDisk_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DetachDisk(ctx context.Context, in *DetachDiskRequest, opts ...grpc.CallOption) (*DetachDiskResponse, error) {
	out := new(DetachDiskResponse)
	err := c.cc.Invoke(ctx, VMService_DetachDisk_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) AttachNic(ctx context.Context, in *AttachNicRequest, opts ...grpc.CallOption) (*AttachNicResponse, error) {
	out := new(AttachNicResponse)
	err := c.cc.Invoke(ctx, VMService_AttachNic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vMServiceClient) DetachNic(ctx context.Context, in *DetachNicRequest, opts ...grpc.CallOption) (*DetachNicResponse, error) {
	out := new(DetachNicResponse)
	err := c.cc.Invoke(ctx, VMService_DetachNic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VMServiceServer is the server API for VMService service.
// All implementations must embed UnimplementedVMServiceServer
// for forward compatibility
type VMServiceServer interface {
	// Creates a new Virtual Machine but does not boot it.
	// This starts a cloud-hypervisor process, sets up its initial resources,
	// and makes it ready for booting. The returned 'vm_id' must be used for
	// all subsequent operations on this VM.
	CreateVm(context.Context, *CreateVmRequest) (*CreateVmResponse, error)
	// Starts a previously created Virtual Machine.
	StartVm(context.Context, *StartVmRequest) (*StartVmResponse, error)
	// Retrieves detailed information about a specific Virtual Machine.
	GetVm(context.Context, *GetVmRequest) (*VmInfo, error)
	// Retrieves the events stream for a specific Virtual Machine.
	StreamVmEvents(*StreamVmEventsRequest, VMService_StreamVmEventsServer) error
	// Deletes an existing Virtual Machine and frees up its resources.
	DeleteVm(context.Context, *DeleteVmRequest) (*DeleteVmResponse, error)
	// Provides an interactive console to a running VM.
	// This is a bidirectional stream. The client first sends an 'attach' message
	// with the VM ID, then streams user input. The server streams back the
	// VM's console output.
	StreamVmConsole(VMService_StreamVmConsoleServer) error
	// Lists all Virtual Machines currently managed by this service.
	ListVms(context.Context, *ListVmsRequest) (*ListVmsResponse, error)
	// Pings the VMM process for a specific VM to check for liveness.
	PingVm(context.Context, *PingVmRequest) (*PingVmResponse, error)
	// Shuts down a running Virtual Machine by sending an ACPI shutdown signal.
	ShutdownVm(context.Context, *ShutdownVmRequest) (*ShutdownVmResponse, error)
	// Pauses a running Virtual Machine.
	PauseVm(context.Context, *PauseVmRequest) (*PauseVmResponse, error)
	// Resumes a paused Virtual Machine.
	ResumeVm(context.Context, *ResumeVmRequest) (*ResumeVmResponse, error)
	// Hot-plugs a new disk to a running VM.
	AttachDisk(context.Context, *AttachDiskRequest) (*AttachDiskResponse, error)
	// Hot-unplugs a disk from a running VM.
	DetachDisk(context.Context, *DetachDiskRequest) (*DetachDiskResponse, error)
	// Hot-plugs a new network interface to a running VM.
	AttachNic(context.Context, *AttachNicRequest) (*AttachNicResponse, error)
	// Hot-unplugs a network interface from a running VM.
	DetachNic(context.Context, *DetachNicRequest) (*DetachNicResponse, error)
	mustEmbedUnimplementedVMServiceServer()
}

// UnimplementedVMServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVMServiceServer struct {
}

func (UnimplementedVMServiceServer) CreateVm(context.Context, *CreateVmRequest) (*CreateVmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVm not implemented")
}
func (UnimplementedVMServiceServer) StartVm(context.Context, *StartVmRequest) (*StartVmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartVm not implemented")
}
func (UnimplementedVMServiceServer) GetVm(context.Context, *GetVmRequest) (*VmInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVm not implemented")
}
func (UnimplementedVMServiceServer) StreamVmEvents(*StreamVmEventsRequest, VMService_StreamVmEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamVmEvents not implemented")
}
func (UnimplementedVMServiceServer) DeleteVm(context.Context, *DeleteVmRequest) (*DeleteVmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVm not implemented")
}
func (UnimplementedVMServiceServer) StreamVmConsole(VMService_StreamVmConsoleServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamVmConsole not implemented")
}
func (UnimplementedVMServiceServer) ListVms(context.Context, *ListVmsRequest) (*ListVmsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVms not implemented")
}
func (UnimplementedVMServiceServer) PingVm(context.Context, *PingVmRequest) (*PingVmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PingVm not implemented")
}
func (UnimplementedVMServiceServer) ShutdownVm(context.Context, *ShutdownVmRequest) (*ShutdownVmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutdownVm not implemented")
}
func (UnimplementedVMServiceServer) PauseVm(context.Context, *PauseVmRequest) (*PauseVmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseVm not implemented")
}
func (UnimplementedVMServiceServer) ResumeVm(context.Context, *ResumeVmRequest) (*ResumeVmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeVm not implemented")
}
func (UnimplementedVMServiceServer) AttachDisk(context.Context, *AttachDiskRequest) (*AttachDiskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachDisk not implemented")
}
func (UnimplementedVMServiceServer) DetachDisk(context.Context, *DetachDiskRequest) (*DetachDiskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachDisk not implemented")
}
func (UnimplementedVMServiceServer) AttachNic(context.Context, *AttachNicRequest) (*AttachNicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachNic not implemented")
}
func (UnimplementedVMServiceServer) DetachNic(context.Context, *DetachNicRequest) (*DetachNicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachNic not implemented")
}
func (UnimplementedVMServiceServer) mustEmbedUnimplementedVMServiceServer() {}

// UnsafeVMServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VMServiceServer will
// result in compilation errors.
type UnsafeVMServiceServer interface {
	mustEmbedUnimplementedVMServiceServer()
}

func RegisterVMServiceServer(s grpc.ServiceRegistrar, srv VMServiceServer) {
	s.RegisterService(&VMService_ServiceDesc, srv)
}

func _VMService_CreateVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).CreateVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_CreateVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).CreateVm(ctx, req.(*CreateVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StartVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).StartVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_StartVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).StartVm(ctx, req.(*StartVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_GetVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).GetVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_GetVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).GetVm(ctx, req.(*GetVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StreamVmEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamVmEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VMServiceServer).StreamVmEvents(m, &vMServiceStreamVmEventsServer{stream})
}

type VMService_StreamVmEventsServer interface {
	Send(*VmEvent) error
	grpc.ServerStream
}

type vMServiceStreamVmEventsServer struct {
	grpc.ServerStream
}

func (x *vMServiceStreamVmEventsServer) Send(m *VmEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _VMService_DeleteVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DeleteVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DeleteVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DeleteVm(ctx, req.(*DeleteVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_StreamVmConsole_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(VMServiceServer).StreamVmConsole(&vMServiceStreamVmConsoleServer{stream})
}

type VMService_StreamVmConsoleServer interface {
	Send(*StreamVmConsoleResponse) error
	Recv() (*StreamVmConsoleRequest, error)
	grpc.ServerStream
}

type vMServiceStreamVmConsoleServer struct {
	grpc.ServerStream
}

func (x *vMServiceStreamVmConsoleServer) Send(m *StreamVmConsoleResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *vMServiceStreamVmConsoleServer) Recv() (*StreamVmConsoleRequest, error) {
	m := new(StreamVmConsoleRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _VMService_ListVms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVmsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ListVms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ListVms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ListVms(ctx, req.(*ListVmsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_PingVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).PingVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_PingVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).PingVm(ctx, req.(*PingVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ShutdownVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ShutdownVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ShutdownVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ShutdownVm(ctx, req.(*ShutdownVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_PauseVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).PauseVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_PauseVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).PauseVm(ctx, req.(*PauseVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_ResumeVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).ResumeVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_ResumeVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).ResumeVm(ctx, req.(*ResumeVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_AttachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).AttachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_AttachDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).AttachDisk(ctx, req.(*AttachDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DetachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DetachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DetachDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DetachDisk(ctx, req.(*DetachDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_AttachNic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachNicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).AttachNic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_AttachNic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).AttachNic(ctx, req.(*AttachNicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VMService_DetachNic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachNicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VMServiceServer).DetachNic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VMService_DetachNic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VMServiceServer).DetachNic(ctx, req.(*DetachNicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VMService_ServiceDesc is the grpc.ServiceDesc for VMService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VMService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "feos.vm.vmm.api.v1.VMService",
	HandlerType: (*VMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVm",
			Handler:    _VMService_CreateVm_Handler,
		},
		{
			MethodName: "StartVm",
			Handler:    _VMService_StartVm_Handler,
		},
		{
			MethodName: "GetVm",
			Handler:    _VMService_GetVm_Handler,
		},
		{
			MethodName: "DeleteVm",
			Handler:    _VMService_DeleteVm_Handler,
		},
		{
			MethodName: "ListVms",
			Handler:    _VMService_ListVms_Handler,
		},
		{
			MethodName: "PingVm",
			Handler:    _VMService_PingVm_Handler,
		},
		{
			MethodName: "ShutdownVm",
			Handler:    _VMService_ShutdownVm_Handler,
		},
		{
			MethodName: "PauseVm",
			Handler:    _VMService_PauseVm_Handler,
		},
		{
			MethodName: "ResumeVm",
			Handler:    _VMService_ResumeVm_Handler,
		},
		{
			MethodName: "AttachDisk",
			Handler:    _VMService_AttachDisk_Handler,
		},
		{
			MethodName: "DetachDisk",
			Handler:    _VMService_DetachDisk_Handler,
		},
		{
			MethodName: "AttachNic",
			Handler:    _VMService_AttachNic_Handler,
		},
		{
			MethodName: "DetachNic",
			Handler:    _VMService_DetachNic_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamVmEvents",
			Handler:       _VMService_StreamVmEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamVmConsole",
			Handler:       _VMService_StreamVmConsole_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "v1/vm.proto",
}
